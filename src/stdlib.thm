;;; CONSTANTS
(define nil ())
(define call/cc call-with-current-continuation)
(define define-macro defmacro)

;;; MACROS
(define-syntax or
  (syntax-rules ()
    ((or) #f)
    ((or test) test)
    ((or test1 test2 ...)
     (let ((x### test1)) ; best we can do until hygiene
       (if x### x### (or test2 ...))))))

(define-syntax and
  (syntax-rules ()
    ((and) #t)
    ((and test) test)
    ((and test1 test2 ...)
     (if test1 (and test2 ...) #f))))

(define-syntax cond
  (syntax-rules (else =>)
    ((cond (else result1 result2 ...))
     (begin result1 result2 ...))
    ((cond (test => result))
     (let ((temp test))
       (if temp (result temp))))
    ((cond (test => result) clause1 clause2 ...)
     (let ((temp test))
       (if temp
           (result temp)
           (cond clause1 clause2 ...))))
    ((cond (test)) test)
    ((cond (test) clause1 clause2 ...)
     (let ((temp test))
       (if temp
           temp
           (cond clause1 clause2 ...))))
    ((cond (test result1 result2 ...))
     (if test (begin result1 result2 ...)))
    ((cond (test result1 result2 ...) clause1 clause2 ...)
     (if test
         (begin result1 result2 ...)
         (cond clause1 clause2 ...)))))

(define-syntax when
  (syntax-rules ()
    ((when test result1 result2 ...)
     (if test (begin result1 result2 ...)))))

(define-syntax unless
  (syntax-rules ()
    ((unless test result1 result2 ...)
     (if (not test)
         (begin result1 result2 ...)))))

;;; BINDINGS

(defmacro defun (name args . body)
  (cond ((pair? args) `(define ,(cons name args) ,@body))
        ((symbol? args) `(define ,name (lambda ,args ,@body)))
        (else (error "defun: Invalid type: expected symbol or pair"))))

; (defmacro let (lst body1 . body*) ; must have at least one body form
;   (if (null? lst) 
;       `(begin ,body1 ,@body*)
;       `((lambda ,(map car lst) ,body1 ,@body*) ,@(map cadr lst))))

(define-syntax let
  (syntax-rules ()
    ((let ((var val) ...) body1 body* ...)
     ((lambda (var ...) body1 body* ...) val ...))
    ((let tag ((var val) ...) body1 body* ...)
     (letrec ([tag (lambda (var ...) body1 body* ...)])
       (tag val ...)))))

; (defmacro let* (lst body1 . body*) ; same as above
;   (if (null? lst)
;       `(let () ,body1 ,@body*)
;       `(let ((,(first (car lst)) ,(second (car lst))))
;          (let* ,(cdr lst) ,body1 ,@body*))))

(define-syntax let*
  (syntax-rules ()
    ((let* (binding1 binding* ...) body1 body* ...)
     (let (binding1) (let* (binding* ...) body1 body* ...)))
    ((let* () body1 body* ...)
     (begin body1 body* ...))))

; (defmacro letrec (lst body1 . body*)
;   (let* ((make-define (lambda (pair)
;            (if (not (pair? pair))
;              (error "letrec: binding is not a pair")
;              (cons 'define pair))))
;          (dfns (map make-define lst)))
;     `(begin ,@dfns ,body1 ,@body*)))

(define-syntax letrec
  (syntax-rules ()
    ((letrec ((var val) ...) body1 body* ...)
     ((lambda () (define var val) ... body1 body* ...)))))

; I don't really know if this one is entirely safe because of
; hygiene concerns. Really, once the hygienic system is in place,
; the local macro should be defined with let-syntax instead.
; Also, recursive case-lambda functions are quite slow as long
; as macros expansion still happens during evaluation.
(define-syntax case-lambda
  (syntax-rules ()
    ((case-lambda (params body0 ...) ...)
     (lambda args
       (let ([len### (length args)])
         (define-syntax cl###
           (syntax-rules ::: ()
             ((cl###)
              (error "no matching clause"))
             ((cl### ((p :::) . body) . rest)
              (if (= len### (length '(p :::)))
                  (apply (lambda (p :::) . body) args)
                  (cl### . rest)))
             ((cl### ((p ::: . tail) . body) . rest)
              (if (>= len (length '(p :::)))
                  (apply
                   (lambda (p ::: . tail) . body)
                   args)
                  (cl### . rest)))))
         (cl### (params body0 ...) ...))))))

;;; LIST FUNCTIONS
(define first car)
(define second cadr)
(define third caddr)

(define (length xs)
  (if (null? xs)
      0
      (+ 1 (length (cdr xs)))))

(define (map f xs)
  (if (null? xs)
      ()
      (cons (f (car xs))
            (map f (cdr xs)))))

(define (map* f . xss)
  (if (null? (car xss))
      ()
      (cons (apply f (map car xss))
            (apply map* (cons f (map cdr xss))))))

(define (filter p xs)
  (if (null? xs)
      ()
      (if (p (car xs))
          (cons (car xs) (filter p (cdr xs)))
          (filter p (cdr xs)))))
