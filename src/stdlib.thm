;;; CONSTANTS
(define nil ())
(define call/cc call-with-current-continuation)
(define define-macro defmacro)

;;; MACROS
(defmacro or cases
  (if (null? cases)
      #f
      `(if ,(car cases)
          #t
          (or ,@(cdr cases)))))

(defmacro and cases
  (if (null? cases)
       #t
       `(if (not ,(car cases))
           #f
           (and ,@(cdr cases)))))

(defmacro cond cases
  (if (null? cases) (error "cond: unexhaustive cases")
      (if (eq? 'else (car (car cases)))
          `(begin ,@(cdr (car cases)))
          `(if ,(car (car cases))
               (begin ,@(cdr (car cases)))
               (cond ,@(cdr cases))))))

(defmacro unless (test-expr body1 . body*)
  `(if ,test-expr () ,body1 ,@body*))

(defmacro when (test-expr body1 . body*)
  `(unless (not ,test-expr) ,body1 ,@body*))

;;; BINDINGS

(defmacro defun (name args . body)
  (cond ((pair? args) `(define ,(cons name args) ,@body))
        ((symbol? args) `(define ,name (lambda ,args ,@body)))
        (else (error "defun: Invalid type: expected symbol or pair"))))

(defmacro let (lst body1 . body*) ; must have at least one body form
  (if (null? lst) 
      `(begin ,body1 ,@body*)
      `((lambda ,(map car lst) ,body1 ,@body*) ,@(map cadr lst))))

(defmacro let* (lst body1 . body*) ; same as above
  (if (null? lst)
      `(let () ,body1 ,@body*)
      `(let ((,(first (car lst)) ,(second (car lst))))
         (let* ,(cdr lst) ,body1 ,@body*))))

(defmacro letrec (lst body1 . body*)
  (let* ((make-define (lambda (pair)
           (if (not (pair? pair))
             (error "letrec: binding is not a pair")
             (cons 'define pair))))
         (dfns (map make-define lst)))
    `(begin ,@dfns ,body1 ,@body*)))

(defmacro named-let (name lst body1 . body*) ; convenient for making loops
  `(letrec ([,name (lambda ,(map car lst) ,body1 ,@body*)])
     (,name ,@(map cadr lst))))

;;; LIST FUNCTIONS
(define first car)
(define second cadr)
(define third caddr)

(define (map f xs)
  (if (null? xs)
      ()
      (cons (f (car xs))
            (map f (cdr xs)))))

(define (map* f . xss)
  (if (null? (car xss))
      ()
      (cons (apply f (map car xss))
            (apply map* (cons f (map cdr xss))))))

(define (filter p xs)
  (if (null? xs)
      ()
      (if (p (car xs))
          (cons (car xs) (filter p (cdr xs)))
          (filter p (cdr xs)))))
