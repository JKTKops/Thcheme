-------------------------------------------------------------------------------
-- Experimental R7RS Scheme lexer written for Haskell using Alex.
-- (c) Max Kopinsky, 2020
--
-- Token definitions mostly follow along with the R7RS formal syntax at
-- the end of the report. We don't work too hard to allow configuarbility,
-- that is future work.
--
-- Alex natively supports Unicode, but does /not/ natively provide macros or
-- any other way to choose only characters which belong to particular chracter
-- sets. We have to define these ourselves.
--
-- Accurate source location is maintained for individual tokens, but not spans.
--
-- See also Parser.y.

{
{-# OPTIONS_GHC -funbox-strict-fields #-}
{-# LANGUAGE NoOverloadedStrings #-}
-- | R7RS Scheme Lexer.
--
-- Full support for the lexical syntax of R7RS Scheme, including full
-- support for unicode characters in (almost) all positions.
-- Wherever an ASCII character might have special meaning to Scheme,
-- that character cannot appear as part of a symbol, e.g. ' and #.
module Parsers.Lexer 
  ( -- * Parsing monad
    Alex, AlexPosn
  , runAlex', alexMonadScan
  , alexErrorWithPos, alexError'
  , stream

    -- * Support for datum labels
  , startDef, endDef, testRef
  , defineLabel, lookupLabel

    -- * Support for datum comments
  , enterDatumComment, exitDatumComment
  , unlessDatumComment

    -- * Tokens
  , Lexeme(..), Token(..)
  , Numeric(..)
  , Byte
  ) where

import Prelude hiding (lex)

import Data.CaseInsensitive (foldCase)
import Data.Char
import Data.Ratio
import Text.Read (readMaybe)
import Control.Applicative ((<|>))
import qualified Data.IntMap as M
import Numeric (readInt, readHex, readFloat)

import Val
}

%wrapper "monadUserState"

-------------------------------------------------------------------------------
-- Character set macros

$dec_digit = 0-9
$hex_digit = [$dec_digit a-f A-F]
$bin_digit = [01]
$oct_digit = [0-7]

$letter = [A-Za-z]
$special_initial = [\! \@ \$ \% \^ \& \* \/ \: \< \= \> \? \_ \~]
$explicit_sign = [\+\-]
  -- the first two are added by hand according to the r7rs spec, the rest are
  -- autogenerated. Note that '#', ',', '\'', and '`' are explicitly excluded at the end.
$initial = [\x200c\x200d\x0021-\x0027\x002a-\x002f\x003a-\x005a\x005c\x005e-\x007a\x007c\x007e\x00a1-\x00aa\x00ac\x00ae-\x00ba\x00bc-\x0377\x037a-\x037f\x0384-\x038a\x038c\x038e-\x03a1\x03a3-\x0487\x048a-\x052f\x0531-\x0556\x0559-\x055f\x0561-\x0587\x0589-\x058a\x058d-\x058f\x0591-\x05c7\x05d0-\x05ea\x05f0-\x05f4\x0606-\x061b\x061e-\x065f\x066a-\x06dc\x06de-\x06ef\x06fa-\x070d\x0710-\x074a\x074d-\x07b1\x07ca-\x07fa\x0800-\x082d\x0830-\x083e\x0840-\x085b\x085e\x08a0-\x08b2\x08e4-\x0902\x0904-\x093a\x093c-\x093d\x0941-\x0948\x094d\x0950-\x0965\x0970-\x0981\x0985-\x098c\x098f-\x0990\x0993-\x09a8\x09aa-\x09b0\x09b2\x09b6-\x09b9\x09bc-\x09bd\x09c1-\x09c4\x09cd-\x09ce\x09dc-\x09dd\x09df-\x09e3\x09f0-\x09fb\x0a01-\x0a02\x0a05-\x0a0a\x0a0f-\x0a10\x0a13-\x0a28\x0a2a-\x0a30\x0a32-\x0a33\x0a35-\x0a36\x0a38-\x0a39\x0a3c\x0a41-\x0a42\x0a47-\x0a48\x0a4b-\x0a4d\x0a51\x0a59-\x0a5c\x0a5e\x0a70-\x0a75\x0a81-\x0a82\x0a85-\x0a8d\x0a8f-\x0a91\x0a93-\x0aa8\x0aaa-\x0ab0\x0ab2-\x0ab3\x0ab5-\x0ab9\x0abc-\x0abd\x0ac1-\x0ac5\x0ac7-\x0ac8\x0acd\x0ad0\x0ae0-\x0ae3\x0af0-\x0af1\x0b01\x0b05-\x0b0c\x0b0f-\x0b10\x0b13-\x0b28\x0b2a-\x0b30\x0b32-\x0b33\x0b35-\x0b39\x0b3c-\x0b3d\x0b3f\x0b41-\x0b44\x0b4d\x0b56\x0b5c-\x0b5d\x0b5f-\x0b63\x0b70-\x0b77\x0b82-\x0b83\x0b85-\x0b8a\x0b8e-\x0b90\x0b92-\x0b95\x0b99-\x0b9a\x0b9c\x0b9e-\x0b9f\x0ba3-\x0ba4\x0ba8-\x0baa\x0bae-\x0bb9\x0bc0\x0bcd\x0bd0\x0bf0-\x0bfa\x0c00\x0c05-\x0c0c\x0c0e-\x0c10\x0c12-\x0c28\x0c2a-\x0c39\x0c3d-\x0c40\x0c46-\x0c48\x0c4a-\x0c4d\x0c55-\x0c56\x0c58-\x0c59\x0c60-\x0c63\x0c78-\x0c7f\x0c81\x0c85-\x0c8c\x0c8e-\x0c90\x0c92-\x0ca8\x0caa-\x0cb3\x0cb5-\x0cb9\x0cbc-\x0cbd\x0cbf\x0cc6\x0ccc-\x0ccd\x0cde\x0ce0-\x0ce3\x0cf1-\x0cf2\x0d01\x0d05-\x0d0c\x0d0e-\x0d10\x0d12-\x0d3a\x0d3d\x0d41-\x0d44\x0d4d-\x0d4e\x0d60-\x0d63\x0d70-\x0d75\x0d79-\x0d7f\x0d85-\x0d96\x0d9a-\x0db1\x0db3-\x0dbb\x0dbd\x0dc0-\x0dc6\x0dca\x0dd2-\x0dd4\x0dd6\x0df4\x0e01-\x0e3a\x0e3f-\x0e4f\x0e5a-\x0e5b\x0e81-\x0e82\x0e84\x0e87-\x0e88\x0e8a\x0e8d\x0e94-\x0e97\x0e99-\x0e9f\x0ea1-\x0ea3\x0ea5\x0ea7\x0eaa-\x0eab\x0ead-\x0eb9\x0ebb-\x0ebd\x0ec0-\x0ec4\x0ec6\x0ec8-\x0ecd\x0edc-\x0edf\x0f00-\x0f1f\x0f2a-\x0f39\x0f40-\x0f47\x0f49-\x0f6c\x0f71-\x0f7e\x0f80-\x0f97\x0f99-\x0fbc\x0fbe-\x0fcc\x0fce-\x0fda\x1000-\x102a\x102d-\x1030\x1032-\x1037\x1039-\x103a\x103d-\x103f\x104a-\x1055\x1058-\x1061\x1065-\x1066\x106e-\x1082\x1085-\x1086\x108d-\x108e\x109d-\x10c5\x10c7\x10cd\x10d0-\x1248\x124a-\x124d\x1250-\x1256\x1258\x125a-\x125d\x1260-\x1288\x128a-\x128d\x1290-\x12b0\x12b2-\x12b5\x12b8-\x12be\x12c0\x12c2-\x12c5\x12c8-\x12d6\x12d8-\x1310\x1312-\x1315\x1318-\x135a\x135d-\x137c\x1380-\x1399\x13a0-\x13f4\x1400-\x167f\x1681-\x169a\x16a0-\x16f8\x1700-\x170c\x170e-\x1714\x1720-\x1736\x1740-\x1753\x1760-\x176c\x176e-\x1770\x1772-\x1773\x1780-\x17b5\x17b7-\x17bd\x17c6\x17c9-\x17dd\x17f0-\x17f9\x1800-\x180d\x1820-\x1877\x1880-\x18aa\x18b0-\x18f5\x1900-\x191e\x1920-\x1922\x1927-\x1928\x1932\x1939-\x193b\x1940\x1944-\x1945\x1950-\x196d\x1970-\x1974\x1980-\x19ab\x19c1-\x19c7\x19da\x19de-\x1a18\x1a1b\x1a1e-\x1a54\x1a56\x1a58-\x1a5e\x1a60\x1a62\x1a65-\x1a6c\x1a73-\x1a7c\x1a7f\x1aa0-\x1aad\x1ab0-\x1abd\x1b00-\x1b03\x1b05-\x1b34\x1b36-\x1b3a\x1b3c\x1b42\x1b45-\x1b4b\x1b5a-\x1b7c\x1b80-\x1b81\x1b83-\x1ba0\x1ba2-\x1ba5\x1ba8-\x1ba9\x1bab-\x1baf\x1bba-\x1be6\x1be8-\x1be9\x1bed\x1bef-\x1bf1\x1bfc-\x1c23\x1c2c-\x1c33\x1c36-\x1c37\x1c3b-\x1c3f\x1c4d-\x1c4f\x1c5a-\x1c7f\x1cc0-\x1cc7\x1cd0-\x1ce0\x1ce2-\x1cf1\x1cf4-\x1cf6\x1cf8-\x1cf9\x1d00-\x1df5\x1dfc-\x1f15\x1f18-\x1f1d\x1f20-\x1f45\x1f48-\x1f4d\x1f50-\x1f57\x1f59\x1f5b\x1f5d\x1f5f-\x1f7d\x1f80-\x1fb4\x1fb6-\x1fc4\x1fc6-\x1fd3\x1fd6-\x1fdb\x1fdd-\x1fef\x1ff2-\x1ff4\x1ff6-\x1ffe\x2010-\x2017\x2020-\x2027\x2030-\x2038\x203b-\x2044\x2047-\x205e\x2070-\x2071\x2074-\x207c\x207f-\x208c\x2090-\x209c\x20a0-\x20bd\x20d0-\x20dc\x20e1\x20e5-\x20f0\x2100-\x2189\x2190-\x2307\x230c-\x2328\x232b-\x23fa\x2400-\x2426\x2440-\x244a\x2460-\x2767\x2776-\x27c4\x27c7-\x27e5\x27f0-\x2982\x2999-\x29d7\x29dc-\x29fb\x29fe-\x2b73\x2b76-\x2b95\x2b98-\x2bb9\x2bbd-\x2bc8\x2bca-\x2bd1\x2c00-\x2c2e\x2c30-\x2c5e\x2c60-\x2cf3\x2cf9-\x2d25\x2d27\x2d2d\x2d30-\x2d67\x2d6f-\x2d70\x2d7f-\x2d96\x2da0-\x2da6\x2da8-\x2dae\x2db0-\x2db6\x2db8-\x2dbe\x2dc0-\x2dc6\x2dc8-\x2dce\x2dd0-\x2dd6\x2dd8-\x2dde\x2de0-\x2e01\x2e06-\x2e08\x2e0b\x2e0e-\x2e1b\x2e1e-\x2e1f\x2e2a-\x2e41\x2e80-\x2e99\x2e9b-\x2ef3\x2f00-\x2fd5\x2ff0-\x2ffb\x3001-\x3007\x3012-\x3013\x301c\x3020-\x302d\x3030-\x303f\x3041-\x3096\x3099-\x30ff\x3105-\x312d\x3131-\x318e\x3190-\x31ba\x31c0-\x31e3\x31f0-\x321e\x3220-\x32fe\x3300-\x4db5\x4dc0-\x9fcc\xa000-\xa48c\xa490-\xa4c6\xa4d0-\xa61f\xa62a-\xa62b\xa640-\xa66f\xa673-\xa69d\xa69f-\xa6f7\xa700-\xa78e\xa790-\xa7ad\xa7b0-\xa7b1\xa7f7-\xa822\xa825-\xa826\xa828-\xa82b\xa830-\xa839\xa840-\xa877\xa882-\xa8b3\xa8c4\xa8ce-\xa8cf\xa8e0-\xa8fb\xa90a-\xa951\xa95f-\xa97c\xa980-\xa982\xa984-\xa9b3\xa9b6-\xa9b9\xa9bc\xa9c1-\xa9cd\xa9cf\xa9de-\xa9ef\xa9fa-\xa9fe\xaa00-\xaa2e\xaa31-\xaa32\xaa35-\xaa36\xaa40-\xaa4c\xaa5c-\xaa7a\xaa7c\xaa7e-\xaac2\xaadb-\xaaea\xaaec-\xaaed\xaaf0-\xaaf4\xaaf6\xab01-\xab06\xab09-\xab0e\xab11-\xab16\xab20-\xab26\xab28-\xab2e\xab30-\xab5f\xab64-\xab65\xabc0-\xabe2\xabe5\xabe8\xabeb\xabed\xac00-\xd7a3\xd7b0-\xd7c6\xd7cb-\xd7fb\xe000-\xfa6d\xfa70-\xfad9\xfb00-\xfb06\xfb13-\xfb17\xfb1d-\xfb36\xfb38-\xfb3c\xfb3e\xfb40-\xfb41\xfb43-\xfb44\xfb46-\xfbc1\xfbd3-\xfd3d\xfd50-\xfd8f\xfd92-\xfdc7\xfdf0-\xfdfd\xfe00-\xfe16\xfe19\xfe20-\xfe2d\xfe30-\xfe34\xfe45-\xfe46\xfe49-\xfe52\xfe54-\xfe58\xfe5f-\xfe66\xfe68-\xfe6b\xfe70-\xfe74\xfe76-\xfefc\xff01-\xff07\xff0a-\xff0f\xff1a-\xff3a\xff3c\xff3e-\xff5a\xff5c\xff5e\xff61\xff64-\xffbe\xffc2-\xffc7\xffca-\xffcf\xffd2-\xffd7\xffda-\xffdc\xffe0-\xffe6\xffe8-\xffee\xfffc-\xfffd\x10000-\x1000b\x1000d-\x10026\x10028-\x1003a\x1003c-\x1003d\x1003f-\x1004d\x10050-\x1005d\x10080-\x100fa\x10100-\x10102\x10107-\x10133\x10137-\x1018c\x10190-\x1019b\x101a0\x101d0-\x101fd\x10280-\x1029c\x102a0-\x102d0\x102e0-\x102fb\x10300-\x10323\x10330-\x1034a\x10350-\x1037a\x10380-\x1039d\x1039f-\x103c3\x103c8-\x103d5\x10400-\x1049d\x10500-\x10527\x10530-\x10563\x1056f\x10600-\x10736\x10740-\x10755\x10760-\x10767\x10800-\x10805\x10808\x1080a-\x10835\x10837-\x10838\x1083c\x1083f-\x10855\x10857-\x1089e\x108a7-\x108af\x10900-\x1091b\x1091f-\x10939\x1093f\x10980-\x109b7\x109be-\x109bf\x10a00-\x10a03\x10a05-\x10a06\x10a0c-\x10a13\x10a15-\x10a17\x10a19-\x10a33\x10a38-\x10a3a\x10a3f-\x10a47\x10a50-\x10a58\x10a60-\x10a9f\x10ac0-\x10ae6\x10aeb-\x10af6\x10b00-\x10b35\x10b39-\x10b55\x10b58-\x10b72\x10b78-\x10b91\x10b99-\x10b9c\x10ba9-\x10baf\x10c00-\x10c48\x10e60-\x10e7e\x11001\x11003-\x1104d\x11052-\x11065\x1107f-\x11081\x11083-\x110af\x110b3-\x110b6\x110b9-\x110bc\x110be-\x110c1\x110d0-\x110e8\x11100-\x1112b\x1112d-\x11134\x11140-\x11143\x11150-\x11176\x11180-\x11181\x11183-\x111b2\x111b6-\x111be\x111c1-\x111c8\x111cd\x111da\x111e1-\x111f4\x11200-\x11211\x11213-\x1122b\x1122f-\x11231\x11234\x11236-\x1123d\x112b0-\x112df\x112e3-\x112ea\x11301\x11305-\x1130c\x1130f-\x11310\x11313-\x11328\x1132a-\x11330\x11332-\x11333\x11335-\x11339\x1133c-\x1133d\x11340\x1135d-\x11361\x11366-\x1136c\x11370-\x11374\x11480-\x114af\x114b3-\x114b8\x114ba\x114bf-\x114c0\x114c2-\x114c7\x11580-\x115ae\x115b2-\x115b5\x115bc-\x115bd\x115bf-\x115c9\x11600-\x1162f\x11633-\x1163a\x1163d\x1163f-\x11644\x11680-\x116ab\x116ad\x116b0-\x116b5\x116b7\x118a0-\x118df\x118ea-\x118f2\x118ff\x11ac0-\x11af8\x12000-\x12398\x12400-\x1246e\x12470-\x12474\x13000-\x1342e\x16800-\x16a38\x16a40-\x16a5e\x16a6e-\x16a6f\x16ad0-\x16aed\x16af0-\x16af5\x16b00-\x16b45\x16b5b-\x16b61\x16b63-\x16b77\x16b7d-\x16b8f\x16f00-\x16f44\x16f50\x16f8f-\x16f9f\x1b000-\x1b001\x1bc00-\x1bc6a\x1bc70-\x1bc7c\x1bc80-\x1bc88\x1bc90-\x1bc99\x1bc9c-\x1bc9f\x1d000-\x1d0f5\x1d100-\x1d126\x1d129-\x1d164\x1d167-\x1d16c\x1d17b-\x1d1dd\x1d200-\x1d245\x1d300-\x1d356\x1d360-\x1d371\x1d400-\x1d454\x1d456-\x1d49c\x1d49e-\x1d49f\x1d4a2\x1d4a5-\x1d4a6\x1d4a9-\x1d4ac\x1d4ae-\x1d4b9\x1d4bb\x1d4bd-\x1d4c3\x1d4c5-\x1d505\x1d507-\x1d50a\x1d50d-\x1d514\x1d516-\x1d51c\x1d51e-\x1d539\x1d53b-\x1d53e\x1d540-\x1d544\x1d546\x1d54a-\x1d550\x1d552-\x1d6a5\x1d6a8-\x1d7cb\x1e800-\x1e8c4\x1e8c7-\x1e8d6\x1ee00-\x1ee03\x1ee05-\x1ee1f\x1ee21-\x1ee22\x1ee24\x1ee27\x1ee29-\x1ee32\x1ee34-\x1ee37\x1ee39\x1ee3b\x1ee42\x1ee47\x1ee49\x1ee4b\x1ee4d-\x1ee4f\x1ee51-\x1ee52\x1ee54\x1ee57\x1ee59\x1ee5b\x1ee5d\x1ee5f\x1ee61-\x1ee62\x1ee64\x1ee67-\x1ee6a\x1ee6c-\x1ee72\x1ee74-\x1ee77\x1ee79-\x1ee7c\x1ee7e\x1ee80-\x1ee89\x1ee8b-\x1ee9b\x1eea1-\x1eea3\x1eea5-\x1eea9\x1eeab-\x1eebb\x1eef0-\x1eef1\x1f000-\x1f02b\x1f030-\x1f093\x1f0a0-\x1f0ae\x1f0b1-\x1f0bf\x1f0c1-\x1f0cf\x1f0d1-\x1f0f5\x1f100-\x1f10c\x1f110-\x1f12e\x1f130-\x1f16b\x1f170-\x1f19a\x1f1e6-\x1f202\x1f210-\x1f23a\x1f240-\x1f248\x1f250-\x1f251\x1f300-\x1f32c\x1f330-\x1f37d\x1f380-\x1f3ce\x1f3d4-\x1f3f7\x1f400-\x1f4fe\x1f500-\x1f54a\x1f550-\x1f579\x1f57b-\x1f5a3\x1f5a5-\x1f642\x1f645-\x1f6cf\x1f6e0-\x1f6ec\x1f6f0-\x1f6f3\x1f700-\x1f773\x1f780-\x1f7d4\x1f800-\x1f80b\x1f810-\x1f847\x1f850-\x1f859\x1f860-\x1f887\x1f890-\x1f8ad\x20000-\x2a6d6\x2a700-\x2b734\x2b740-\x2b81d\x2f800-\x2fa1d\xe0100-\xe01ef\xf0000-\xffffd\x100000-\x10fffd] # [\# \| \" \' \` \,]
$special_subsequent = [$explicit_sign \. \@]
$sign_subsequent = [$initial $explicit_sign \@]
$dot_subsequent  = [$sign_subsequent \.]
$subsequent_unicode_chars = [\x0030-\x0039\x0488-\x0489\x0660-\x0669\x06f0-\x06f9\x07c0-\x07c9\x0903\x093b\x093e-\x0940\x0949-\x094c\x094e-\x094f\x0966-\x096f\x0982-\x0983\x09be-\x09c0\x09c7-\x09c8\x09cb-\x09cc\x09d7\x09e6-\x09ef\x0a03\x0a3e-\x0a40\x0a66-\x0a6f\x0a83\x0abe-\x0ac0\x0ac9\x0acb-\x0acc\x0ae6-\x0aef\x0b02-\x0b03\x0b3e\x0b40\x0b47-\x0b48\x0b4b-\x0b4c\x0b57\x0b66-\x0b6f\x0bbe-\x0bbf\x0bc1-\x0bc2\x0bc6-\x0bc8\x0bca-\x0bcc\x0bd7\x0be6-\x0bef\x0c01-\x0c03\x0c41-\x0c44\x0c66-\x0c6f\x0c82-\x0c83\x0cbe\x0cc0-\x0cc4\x0cc7-\x0cc8\x0cca-\x0ccb\x0cd5-\x0cd6\x0ce6-\x0cef\x0d02-\x0d03\x0d3e-\x0d40\x0d46-\x0d48\x0d4a-\x0d4c\x0d57\x0d66-\x0d6f\x0d82-\x0d83\x0dcf-\x0dd1\x0dd8-\x0ddf\x0de6-\x0def\x0df2-\x0df3\x0e50-\x0e59\x0ed0-\x0ed9\x0f20-\x0f29\x0f3e-\x0f3f\x0f7f\x102b-\x102c\x1031\x1038\x103b-\x103c\x1040-\x1049\x1056-\x1057\x1062-\x1064\x1067-\x106d\x1083-\x1084\x1087-\x108c\x108f-\x109c\x17b6\x17be-\x17c5\x17c7-\x17c8\x17e0-\x17e9\x1810-\x1819\x1923-\x1926\x1929-\x192b\x1930-\x1931\x1933-\x1938\x1946-\x194f\x19b0-\x19c0\x19c8-\x19c9\x19d0-\x19d9\x1a19-\x1a1a\x1a55\x1a57\x1a61\x1a63-\x1a64\x1a6d-\x1a72\x1a80-\x1a89\x1a90-\x1a99\x1abe\x1b04\x1b35\x1b3b\x1b3d-\x1b41\x1b43-\x1b44\x1b50-\x1b59\x1b82\x1ba1\x1ba6-\x1ba7\x1baa\x1bb0-\x1bb9\x1be7\x1bea-\x1bec\x1bee\x1bf2-\x1bf3\x1c24-\x1c2b\x1c34-\x1c35\x1c40-\x1c49\x1c50-\x1c59\x1ce1\x1cf2-\x1cf3\x20dd-\x20e0\x20e2-\x20e4\x302e-\x302f\xa620-\xa629\xa670-\xa672\xa823-\xa824\xa827\xa880-\xa881\xa8b4-\xa8c3\xa8d0-\xa8d9\xa900-\xa909\xa952-\xa953\xa983\xa9b4-\xa9b5\xa9ba-\xa9bb\xa9bd-\xa9c0\xa9d0-\xa9d9\xa9f0-\xa9f9\xaa2f-\xaa30\xaa33-\xaa34\xaa4d\xaa50-\xaa59\xaa7b\xaa7d\xaaeb\xaaee-\xaaef\xaaf5\xabe3-\xabe4\xabe6-\xabe7\xabe9-\xabea\xabec\xabf0-\xabf9\xff10-\xff19\x104a0-\x104a9\x11000\x11002\x11066-\x1106f\x11082\x110b0-\x110b2\x110b7-\x110b8\x110f0-\x110f9\x1112c\x11136-\x1113f\x11182\x111b3-\x111b5\x111bf-\x111c0\x111d0-\x111d9\x1122c-\x1122e\x11232-\x11233\x11235\x112e0-\x112e2\x112f0-\x112f9\x11302-\x11303\x1133e-\x1133f\x11341-\x11344\x11347-\x11348\x1134b-\x1134d\x11357\x11362-\x11363\x114b0-\x114b2\x114b9\x114bb-\x114be\x114c1\x114d0-\x114d9\x115af-\x115b1\x115b8-\x115bb\x115be\x11630-\x11632\x1163b-\x1163c\x1163e\x11650-\x11659\x116ac\x116ae-\x116af\x116b6\x116c0-\x116c9\x118e0-\x118e9\x16a60-\x16a69\x16b50-\x16b59\x16f51-\x16f7e\x1d165-\x1d166\x1d16d-\x1d172\x1d7ce-\x1d7ff]
$subsequent = [$initial \# \| $subsequent_unicode_chars]

$not_pipe_or_backslash = $printable # [ \| \\ ]
$not_dquot_or_backslash = $printable # [ \" \\ ]

$exactness_indicator = [ieIE]
$exponent_marker = [eE]
$complex_i       = [iI]
$radix_indicator = [bodxBODX]

$intraline_whitespace = [\ \t]

$delimiter = [$white \| \( \) \[ \] \{ \} \; \"]

-------------------------------------------------------------------------------
-- Regex macros

@inline_hex_escape = \\x $hex_digit + \;
@mnemonic_escape = \\a | \\b | \\t | \\n | \\r
@peculiar_identifier = 
  $explicit_sign | $explicit_sign $sign_subsequent $subsequent *
                 | $explicit_sign \. $dot_subsequent $subsequent *
                 | \. $dot_subsequent $subsequent *

@symbol_element = $not_pipe_or_backslash
                | @inline_hex_escape
                | @mnemonic_escape
                | \\\|

@character_name = alarm|backspace|delete|escape|newline|null|return|space|tab
@character = \#\\ . | \#\\ @character_name | \# \\ x $hex_digit +

@line_ending = \r | \r\n | \n
@string_element
  = $not_dquot_or_backslash
  | @mnemonic_escape
  | \\ \"
  | \\ \\
  | \\ $intraline_whitespace * @line_ending $intraline_whitespace *
  | @inline_hex_escape
@string = \" @string_element * \"

-- stuff for numbers
-- Rather than duplicating all the rules for each type of number
-- (which would generate awful lexer errors)
-- anything that looks like it could be a number gets lexed as
-- though it were a hex literal, and then we check in the actions
-- that the token contains characters from the radix it claims to
-- use.
@sign = $explicit_sign?
@radix = (\# $radix_indicator)?
@exactness = (\# $exactness_indicator)?

@prefix = @radix @exactness | @exactness @radix
@dec_prefix = \# "d" @exactness | @exactness \# "d"?
@explicit_suffix = $exponent_marker @sign $dec_digit+
@suffix = @explicit_suffix?
@infnan = "+inf.0" | "-inf.0" | "+nan.0" | "-nan.0"

@uint_hex = $hex_digit+
@int_hex = @sign @uint_hex
-- Note that actually using any floating-point syntax requires base 10
@decimal_hex = @uint_hex @suffix
  | \. $hex_digit+ @suffix
  | $hex_digit+ \. $hex_digit* @suffix
@ureal_hex = @uint_hex | @uint_hex "/" @uint_hex | @decimal_hex
@real_hex = @sign @ureal_hex | @infnan
@rational_hex = @int_hex "/" @uint_hex
@complex_hex = @real_hex | @real_hex \@ @real_hex
  -- <real>+<ureal>i, <real>-<ureal>i, <real>+i, <real>-i
  | @real_hex $explicit_sign @ureal_hex? $complex_i
  | @real_hex @infnan $complex_i
  | $explicit_sign @ureal_hex $complex_i
  | @infnan $complex_i | $explicit_sign $complex_i
@num_hex = @prefix @complex_hex


-------------------------------------------------------------------------------
-- finally, rules!

tokens :-

<0> {
  $white+                   ;
  "#|"                      { nestedComment }
  ";" (~[\r\n])*            ;
  
  \)                        { lex' TokRParen }
  \(                        { lex' TokLParen }
  \[                        { lex' TokLBracket }
  \]                        { lex' TokRBracket }
  \{                        { lex' TokLBrace }
  \}                        { lex' TokRBrace }
  \# \(                     { lex' TokLVector }
  \# "u8" \(                { lex' TokLByteVector }
  "'"                       { lex' TokQuote }
  "`"                       { lex' TokBackquote }
  ","                       { lex' TokComma }
  ",@"                      { lex' TokCommaAt }
  "." /$delimiter           { lex' TokDot }
  "#;"                      { lex' TokDatumComment }
  
  \# $dec_digit+ \=         { lex tokLabelDef }
  \# $dec_digit+ \#         { lex tokLabelRef }
  
  -- things that start with '#'
  -- R7RS doesn't say that we have to allow identifiers to start with '#'.
  -- In fact, with the given grammar, they can't. However, it also says we
  -- can allow any additional repertoire of Unicode characters, so we
  -- allow them all. However, currently, we specifically _don't_ allow
  -- identifiers to begin with '#', because it precludes nice errors for
  -- badly formatted numbers. This is future-proofing. A directive like
  -- "#!magic-hash" to enable hashes in identifiers is probably the right way
  -- to go. 'lexNumeric' would have to check if that setting is on to decide
  -- if '#' triggers 'mightBeSymbol' or not. '#' can be safely added back
  -- to $initial with no other complications afaik.
  "#f"      /$delimiter     { lex' (TokBool False) }
  "#false"  /$delimiter     { lex' (TokBool False) }
  "#t"      /$delimiter     { lex' (TokBool True) }
  "#true"   /$delimiter     { lex' (TokBool True) }

  \# \\ .              /$delimiter { lexChar }
  \# \\ x $hex_digit+  /$delimiter { unicodeEscapeChar }
  \# \\ $letter+       /$delimiter { namedChar }

  \# \! $initial $subsequent+ /$delimiter { directive }

  \"                        { begin string }

  -- This case of decimal notation has to come first because
  -- 1e4 is decimal, but also looks like a hex integer.
  -- According to the R7RS grammar, we should only even attempt this
  -- reading if the radix is 10, so if we see any radix other than 10,
  -- the lexer will match in @prefix @int_hex instead.
  @dec_prefix @int_hex
    @explicit_suffix
      /$delimiter           { lexNumeric tokDecimal }
  @prefix @int_hex      
      /$delimiter           { lexNumeric tokInt }
  @prefix @sign @decimal_hex
      /$delimiter           { lexNumeric tokDecimal }
  @prefix @rational_hex
      /$delimiter           { lexNumeric tokRational }
  @prefix @infnan         
      /$delimiter           { lexNumeric tokInfnan }
  
  @prefix 
    @real_hex \@ @real_hex
      /$delimiter           { lexNumeric tokComplexPolar }
  @prefix @complex_hex
      /$delimiter           { lexNumeric tokComplex }
  
  -- Previously, the first two cases were above numbers with a note about
  -- some weird overlap because we lex all number as hex numbers.
  -- This is no longer a problem, because 'lexNumeric' will fall back to
  -- outputting a symbol if the token can't be read as a number.
  "|"                      { begin litSymbol }
  $initial $subsequent*    { lexFolded TokSymbol }
  @peculiar_identifier     { lexFolded TokSymbol }
}

<string> {
  \"                        { endString }
  .                         { stringChar }
  \\ x $hex_digit+ \;       { unicodeEscape }
  \\ $intraline_whitespace*
     @line_ending
     $intraline_whitespace* { skip }
  \\ .                      { escapeChar } -- see the R7RS-small errata, which
                                           -- says that strings and symbols
                                           -- should have the same set of
                                           -- escapes.
}

<litSymbol> {
  "|"                       { endSymbol }
  .                         { stringChar } -- symbolChar would be the same
  \\ x $hex_digit+ \;       { unicodeEscape }
  \\ .                      { escapeChar }
}

{

-- for testing
-- | Convert a source string into a list of lexemes.
-- Primarily useful for testing the lexer.
stream :: String -> Either String [Lexeme]
stream = runAlex' loop "<stream>" where
  loop = do
    l <- alexMonadScan
    case l of
      L _ TokEOF -> return []
      other -> (other:) <$> loop

data PState
  = PState { source_name :: String
    
           , workingMap  :: Labels
           , completeMap :: Labels
             -- | Don't define new labels while parsing a datum comment.
             -- Note: we could use one field for both nested block comments
             -- and nested datum comments, but this would make the code
             -- harder to maintain without substantial gain. The lexer is
             -- threaded through the parser, so sometimes we will have to
             -- lex (nested) block comments in the middle of parsing a (nested)
             -- datum comment.
           , datum_comment_depth :: !Int
           , block_comment_depth :: !Int
             -- | Used to detect the #0=#0# error. Stores the value of
             -- the label currently being defined and the location we should
             -- use if we need to produce an error message.
           , defining_label :: Maybe (AlexPosn, Int)
           
             -- | Used while tokenizing strings and vertical-bar identifiers
             -- as scratch space to build a string.
           , scratch_space :: String

             -- | To integrate with a Scheme implementation, this should be
             -- replaced by a set of flags as appropriate.
           , fold_case :: Bool
           }

initializePState :: String -> Labels -> PState
initializePState srcName completeMap
  = PState { source_name = srcName
           , workingMap = M.empty
           , completeMap = completeMap
           , datum_comment_depth = 0
           , block_comment_depth = 0
           , defining_label = Nothing
           , scratch_space = ""
           , fold_case = False
           }

type Labels = M.IntMap Val
type AlexUserState = PState

alexInitUserState :: PState
alexInitUserState = error "someone used runAlex. Use runAlex' instead!"

-- | Run an Alex parser, giving a source name and the source itself.
-- Returns either a string representing a lexical error, or the result type
-- of the parser.
-- Handles the black-magic laziness that is used to support datum labels.
runAlex' :: Alex a -> String -> String -> Either String a
runAlex' (Alex f) srcName input =
  let r = f AlexState { alex_pos = alexStartPos
                        -- append a newline so that $delimiter doesn't choke on EOF
                      , alex_inp = input ++ "\n"
                      , alex_chr = '\n'
                      , alex_bytes = []
                        -- it is absolutely crucial that the 'mapFromResult r'
                        -- thunk is never forced until the parse is over. If
                        -- the parse fails, we won't ever be trying to force
                        -- problematic vals. If the parse succeeds, then there
                        -- is a map that we can use and we should be good
                        -- to go.
                      , alex_ust = initializePState srcName $ mapFromResult r
                      , alex_scd = 0
                      }
  in case r of
    Left msg    -> Left msg
    Right (_,a) -> Right a
  where
    mapFromResult Left{} = error "result forced early (but you probably won't see this because it will just hang)"
    mapFromResult (Right (AlexState{alex_ust = PState{workingMap = m}}, _)) = m

alexState :: (PState -> (a, PState)) -> Alex a
alexState f = Alex $ \s@AlexState{alex_ust=ust} ->
  let (a, ust') = f ust in Right (s{alex_ust = ust'}, a)
{-# INLINE alexState #-}

alexGet :: Alex PState
alexGet = alexState $ \s -> (s, s)

alexPut :: PState -> Alex ()
alexPut s = alexState $ const ((), s)

alexModify :: (PState -> PState) -> Alex ()
alexModify f = fmap f alexGet >>= alexPut

modifyScratchSpace :: (String -> String) -> Alex ()
modifyScratchSpace f = alexModify $ \s -> 
  s { scratch_space = f (scratch_space s) }

-- | 'startDef' p i signals that the parser is reading a datum attached to a
-- definition for label i, which occured at position p.
startDef :: AlexPosn -> Int -> Alex ()
startDef p i = alexModify $ \s -> s { defining_label = Just (p, i) }

-- | Signals that the parser is not reading a labeled datum.
endDef :: Alex ()
endDef = alexModify $ \s -> s { defining_label = Nothing }

-- | Test if a label reference is well-defined. A label is ill-defined
-- if it is equal to itself, i.e. #0=#0# or #0=(. #0#).
testRef :: Int -> Alex ()
testRef i = do
  PState { defining_label = lbl } <- alexGet
  case lbl of
    Just (p, j) | i == j ->
      -- I'm not sure that it's correct to use an implicit location
      -- here. I think it'll always be one token too far ahead.
      alexErrorWithPos p $ "label " ++ show i ++ " is not well-defined."
    _otherwise -> return ()

-- | 'defineLabel' i v sets the value given by the label #i= to v.
defineLabel :: Int -> Val -> Alex ()
defineLabel i v = alexModify $ \s@PState { workingMap = m } ->
  s { workingMap = M.insert i v m }

-- Perhaps it would be better to return Symbol "#<n>#" since that's not
-- actually a valid Symbol. Then a validation pass after the parser
-- could produce a nicer error message. But then in a "strict" mode
-- we'd probably have to leave Unspecified so that we don't leave invalid
-- symbols in the tree.

-- | 'lookuplabel' i gets the value given by the label #i= in the source.
-- Through black magic, 'lookupLabel' is able to return the value even if
-- no calls have yet been made to 'defineLabel' i. However, you must remain
-- lazy in the result of 'lookupLabel', or else the parser will hang.
lookupLabel :: Int -> Alex Val
lookupLabel i = do
  PState { completeMap = m } <- alexGet
  -- floating the 'return' here is very important. If you push
  -- the 'return' inside the case branches, the parser won't be
  -- lazy in the result of M.!?, and that will cause the parser
  -- to hang.
  --
  -- It's unclear to me if "strict" mode should leave the Unspecifieds
  -- or if it should signal an error. R7RS doesn't comment at all,
  -- so I think the natural behavior is to signal an error and the
  -- strict behavior would be to leave the 'Unspecified's.
  return $ case m M.!? i of
    Nothing -> Undefined -- TODO: don't use undefined here!
    Just v  -> v

-- | 'unlessDatumComment m' performs the action 'm' only if the parser
-- is not currently reading a datum comment.
unlessDatumComment :: Alex () -> Alex ()
unlessDatumComment alex = do
  PState { datum_comment_depth = d } <- alexGet
  if d /= 0 then pure () else alex


enterDatumComment, exitDatumComment :: Alex ()
-- | Signal that the parser has just begun reading a datum
-- commented out by \#;
enterDatumComment = alexModify $ \s -> 
  s { datum_comment_depth = datum_comment_depth s + 1 }
-- | Signal that the parser has finished reading a datum
-- that was commented out by \#;
exitDatumComment = alexModify $ \s -> 
  s { datum_comment_depth = datum_comment_depth s - 1 }

-- | The type of Scheme lexemes.
data Lexeme = L AlexPosn Token
  deriving Show

-- | The type of Scheme tokens.
data Token
  = TokSymbol   String
  | TokBool     Bool
  | TokNumber   Numeric
  | TokChar     Char
  | TokString   String
  | TokLParen
  | TokRParen
  | TokLBracket
  | TokRBracket
  | TokLBrace
  | TokRBrace
  | TokLVector
  | TokLByteVector
  | TokQuote
  | TokBackquote
  | TokComma
  | TokCommaAt
  | TokDot
  | TokLabelDef Int
  | TokLabelRef Int
  
  | TokDatumComment -- throwing away datum comments requires parsing the datum
                    -- to figure out its exact extent. We have to be a bit
                    -- careful with labels; see Parser.y and the PState
                    -- type.
                    -- The actual token is just '#;'.

  | TokEOF

instance Show Token where
  show tok = case tok of
    TokSymbol s -> s; TokBool True -> "#t"; TokBool False -> "#f";
    TokNumber n -> show n; TokChar c -> show c; TokString s -> show s;
    TokLParen -> "("; TokRParen -> ")"; TokLBracket -> "["; TokRBracket -> "]";
    TokLBrace -> "{"; TokRBrace -> "}"; TokLVector -> "#(";
    TokLByteVector -> "#u8(";
    TokQuote -> "'"; TokBackquote -> "`"; TokComma -> ","; TokCommaAt -> ",@";
    TokDot -> ".";
    TokLabelDef i -> "#" ++ show i ++ "=";
    TokLabelRef i -> "#" ++ show i ++ "#";
    TokDatumComment -> "#;"
    TokEOF -> "EOF";

-- | The payload of a numeric lexeme.
data Numeric
  = LitInteger  Integer
  | LitFloating Double
  | LitRational Rational
  | LitComplex  Numeric Numeric

instance Show Numeric where
  show (LitInteger i) = show i -- this one is diff bc it appears in byte errors
  show _ = "NumericToken"

lex :: (String -> Token) -> AlexAction Lexeme
lex f = \(p,_,_,s) i -> return $ L p (f (take i s))

lex' :: Token -> AlexAction Lexeme
lex' = lex . const

lexFolded :: (String -> Token) -> AlexAction Lexeme
lexFolded f = \(p,_,_,s) i -> do
  fold <- getFoldFun
  return $ L p $ f $ fold $ take i s

partialLex :: AlexAction a -> AlexAction Lexeme
partialLex act = \s i -> act s i >> skip s i

alexEOF :: Alex Lexeme
alexEOF = do
  (p,_,_,_) <- alexGetInput
  return $ L p TokEOF

tokLabelDef, tokLabelRef :: String -> Token
tokLabelDef ('#' : tl) = TokLabelDef $ read $ init tl
tokLabelRef ('#' : tl) = TokLabelRef $ read $ init tl

directive :: AlexAction Lexeme
directive = partialLex $ \a@(p,_,_,s) i ->
  let name = drop 2 $ take i s in
  case name of
    "fold-case" -> alexModify $ \s -> s { fold_case = True }
    "no-fold-case" -> alexModify $ \s -> s { fold_case = False }
    other -> alexErrorWithPos p $ "unrecognized directive: " ++ other

getFoldFun :: Alex (String -> String)
getFoldFun = do
  fold <- fold_case <$> alexGet
  return $ if fold then foldCase else id

-------------------------------------------------------------------------------
-- Tokenizing Strings
-------------------------------------------------------------------------------

endString :: AlexAction Lexeme
endString = \(p,_,_,_) _ -> do
  scratch <- scratch_space <$> alexGet
  modifyScratchSpace $ const ""
  alexSetStartCode 0
  return $ L p $ TokString $ reverse scratch

addScratch :: Char -> Alex ()
addScratch c = modifyScratchSpace (c:)

stringChar :: AlexAction Lexeme
stringChar = partialLex $ \(_,_,_,(c:_)) _ -> addScratch c

escapeChar :: AlexAction Lexeme
escapeChar = partialLex $ \(p,_,_,'\\':e:_) _ -> case e of
  'a' -> addScratch '\a'
  'b' -> addScratch '\b'
  't' -> addScratch '\t'
  'n' -> addScratch '\n'
  'r' -> addScratch '\r'
  '\\' -> addScratch '\\'
  '"' -> addScratch '"'
  '|' -> addScratch '|'
  other -> alexErrorWithPos p $ "unknown escape: " ++ ['\\', e]

-- characters like '\x3bb;'. We use (i-1) to drop the semicolon.
unicodeEscape :: AlexAction Lexeme
unicodeEscape = partialLex $ \(p,_,_,s) i ->
  addScratch =<< unUnicodeEscape p (drop 2 $ take (i-1) s)

-------------------------------------------------------------------------------
-- Tokenizing Symbols, very similar to strings
-------------------------------------------------------------------------------

endSymbol :: AlexAction Lexeme
endSymbol = \(p,_,_,_) _ -> do
  scratch <- scratch_space <$> alexGet
  modifyScratchSpace $ const ""
  alexSetStartCode 0
  fold <- getFoldFun
  return $ L p $ TokSymbol $ fold $ reverse scratch

-------------------------------------------------------------------------------
-- Character tokens
-------------------------------------------------------------------------------

lexChar :: AlexAction Lexeme
lexChar = lex $ \['#', '\\', c] -> TokChar c

charNames :: [(String, Char)]
charNames = 
  [ ("alarm", '\a')
  , ("backspace", '\b')
  , ("delete", '\127')
  , ("escape", '\27')
  , ("newline", '\n')
  , ("null", '\0')
  , ("return", '\r')
  , ("space", ' ')
  , ("tab", '\t')
  ]

namedChar :: AlexAction Lexeme
namedChar = \(p,_,_,s) i -> do
  fold <- getFoldFun
  let name = drop 2 $ take i s
      mchar = lookup (fold name) charNames
  case mchar of
    Just c  -> return $ L p $ TokChar c
    Nothing -> alexErrorWithPos p $ "unknown character name: " ++ name

-- this one is a bit different from unicodeEscape for strings and symbols.
-- In those, we want to add the character to the scratch space but here we
-- just want to throw it into a character.
unicodeEscapeChar :: AlexAction Lexeme
unicodeEscapeChar = \(p,_,_,s) i -> do
       -- drop # \ x
  c <- unUnicodeEscape p $ drop 3 $ take i s
  return $ L p $ TokChar c

unUnicodeEscape :: AlexPosn -> String -> Alex Char
unUnicodeEscape p hex
  | n < 0 || n > 0x10FFFF 
  = alexErrorWithPos p $ "bad unicode escape value: \\x" ++ hex
  | otherwise = return $ chr n
  where
    readHexNum s = case readHex s of
      [(n,"")] -> n
    n = readHexNum hex

-------------------------------------------------------------------------------
-- numeric tokens
-------------------------------------------------------------------------------

data Exactness = Exact | Inexact | NoExactness
  deriving Show
type Radix = Int

readStoEither :: ReadS a -> String -> Either String a
readStoEither readS = \inp -> case readS inp of
  [(a, "")] -> Right a
  _         -> Left $ error $ 
    "panic! Lexer failed to catch an error with token: " ++ inp

-- | Does what 'Numeric.readSigned' does, except it actually works on
-- non-decimal numbers and works better (see the source comments in Numeric).
readSigned :: Num a => (String -> Either String a) -> String -> Either String a
readSigned f ('+':str) = f str
readSigned f ('-':str) = negate <$> f str
readSigned f unsigned  = f unsigned

catchRadix :: Radix -> Either String a -> Either String a
catchRadix r e = case e of
  Left{}  -> Left $ "bad " ++ radixName r ++ " character"
  Right n -> Right n

lexNumeric :: (Radix -> Exactness -> String -> Either String Numeric)
               -- ^ parse a number given a radix and exactness
            -> AlexAction Lexeme
lexNumeric f = \(p,_,_,s) i -> 
  let tok = take i s
      (str, r, e) = stripPrefixes tok
      -- There's some overlap with peculiar identifiers here,
      -- e.x. +deadbeef should be read as a symbol, not as a bad
      -- decimal number.
      mightBeSymbol = case tok of
        '+':_ -> True
        '-':_ -> True
        --'#':_ -> True
        c:_   -> isLetter c
        _     -> False
  in case f r e str of
    Left err 
      | mightBeSymbol -> return $ L p $ TokSymbol tok
      | otherwise -> alexErrorWithPos p $ err ++ " in token " ++ tok
    Right n  -> return $ L p $ TokNumber n

stripPrefixes :: String -> (String, Radix, Exactness)
stripPrefixes ('#' : p1 : '#' : p2 : rest) =
  let (r,e) = twoPrefixes p1 p2
  in (rest, r, e)
stripPrefixes ('#' : p : rest) =
  let (r,e) = onePrefix p
  in (rest, r, e)
stripPrefixes str = (str, 10, NoExactness)

twoPrefixes :: Char -> Char -> (Radix, Exactness)
twoPrefixes p1 p2
  | p1 `elem` "ie" = twoPrefixes p2 p1
  | otherwise = (radix p1, exactness p2)

onePrefix :: Char -> (Radix, Exactness)
onePrefix p
  | p `elem` "ie" = (10, exactness p)
  | otherwise     = (radix p, NoExactness)

radix :: Char -> Radix
radix c = case toLower c of
  'b' -> 2
  'o' -> 8
  'd' -> 10
  'x' -> 16

exactness :: Char -> Exactness
exactness c = case toLower c of
  'e' -> Exact
  'i' -> Inexact

radixName :: Radix -> String
radixName 2  = "binary"
radixName 8  = "octal"
radixName 10 = "decimal"
radixName 16 = "hex" -- I'm not sure this can actually happen, because the
                     -- the lexer won't even try and call the number reader.

tokInt, tokRational, tokInfnan, tokDecimal, tokComplex, tokComplexPolar
  :: Radix -> Exactness -> String -> Either String Numeric

tokInt r exactness s = case exactness of
  Exact -> exactInt r s
  Inexact -> inexactInt r s
  NoExactness -> exactInt r s
  where
    exactInt r = parseInt r
    inexactInt r = fmap numericInexact . parseInt r

tokRational r exactness s = possiblyInexact exactness $ parseRational r s
  where
    possiblyInexact Inexact = fmap numericInexact
    possiblyInexact Exact = id
    possiblyInexact NoExactness = id

tokInfnan _ _ s = parseInfnan s

tokDecimal r Exact s = parseExactDecimal r s
tokDecimal r _ s = parseDecimal r s

tokComplex r Exact s = parseExactComplex r s
tokComplex r _ s = parseComplex r s

tokComplexPolar r _ s = parsePolarComplex r s

parseInfnan :: String -> Either String Numeric
parseInfnan (sign : "nan.0") = Right $ LitFloating $ 0/0
parseInfnan "+inf.0" = Right $ LitFloating $ 1/0
parseInfnan "-inf.0" = Right $ LitFloating $ -1/0
parseInfnan _ = Left "not infnan"

parseInt :: Radix -> String -> Either String Numeric
parseInt r s = LitInteger <$> catchRadix r (tryReadInt s)
  where
    tryReadInt :: String -> Either String Integer
    tryReadInt = readSigned $ readStoEither $
      readInt (toInteger r) (validChar r) digitToInt

validChar :: Radix -> Char -> Bool
validChar r c = case r of
  2  -> c `elem` ['0','1']
  8  -> c >= '0' && c <= '7'
  10 -> isDigit c
  16 -> isHexDigit c

parseRational :: Radix -> String -> Either String Numeric
parseRational r s = LitRational <$> catchRadix r (readSigned reader s)
  where 
    reader str = do
      (numS, denomS) <- splitNumeric '/' str
      num <- readOne numS
      denom <- readOne denomS
      return $ num % denom
    readOne = readStoEither $ readInt (toInteger r) (validChar r) digitToInt

parseDecimal :: Radix -> String -> Either String Numeric
parseDecimal 10 str = fmap LitFloating $ readSigned readEither $ str'
  -- '.0' is valid in Scheme, but not Haskell.
  where
    str' = case str of
      ('+':r) -> '+':'0':r
      ('-':r) -> '-':'0':r
      other -> '0' : other
    readEither s = case readMaybe s of
      Just x -> Right x
      Nothing -> Left "bad decimal character"
parseDecimal _ _ = Left "decimal numbers must use base 10;"

-- like parseDecimal, but returns a rational instead.
-- We can't use toRational :: Double -> Rational. Why? Computers are dumb:
-- toRational 0.3 => 5404319552844595 % 18014398509481984
-- which is absolutely not the exact rational value of 0.3
-- (even if it is a good approximation).
parseExactDecimal :: Radix -> String -> Either String Numeric
parseExactDecimal 10 s = LitRational <$> reader s
  where
    reader = readSigned $ readStoEither readFloat
parseExactDecimal _ _ = Left "decimal numbers must use base 10;"

parseReal :: Radix -> String -> Either String Numeric
parseReal r str = catchRadix r $
  parseInt r str <|> parseRational r str 
                 <|> parseDecimal r str
                 <|> parseInfnan str

parseExactReal :: Radix -> String -> Either String Numeric
parseExactReal r str = catchRadix r $
  parseInt r str <|> parseRational r str 
                 <|> parseExactDecimal r str
                 <|> parseInfnan str


parseComplex, parseExactComplex :: Radix -> String -> Either String Numeric
parseComplex = parseComplexAux parseReal
parseExactComplex = parseComplexAux parseExactReal

parseComplexAux :: (Radix -> String -> Either String Numeric)
                   -- ^ parse components
                -> Radix -> String -> Either String Numeric
parseComplexAux parseReal r str = LitComplex <$> real <*> imag
  where
    (reals, imags) = case parsePart str of
      Right i -> ("0", i)
      Left (r, rest) -> case parsePart rest of
        Right i -> (r, i)
        Left{} -> error "second part in complex token didn't end in 'i'"

    real = parseReal r reals
    imag = case imags of
      "+" -> Right $ LitInteger 1
      "-" -> Right $ LitInteger (-1)
      other -> parseReal r other

    -- left = real+remainder, right = imag
    parsePart :: String -> Either (String, String) String
    parsePart [] = error "lexer matched empty string as @complex_hex"
    parsePart (c:cs)
      | c `elem` "+-" = attach c $ go cs id
      | otherwise     = go (c:cs) id
      where
        go ""  k = Left (k "", "")
        go ('e':c:cs) k -- scientific notation
          | c `elem` "+-" = go cs (k . (['e', c]++))
        go (c:cs) k
          | c `elem` "+-" = Left (k "", c:cs)
        go "i" k = Right (k "")
        go (c:cs) k = go cs (k . (c:))
        
        attach c (Left (thing, rest)) = Left (c:thing, rest)
        attach c (Right thing) = Right (c:thing)

parsePolarComplex :: Radix -> String -> Either String Numeric
parsePolarComplex radix str = do
  let Right (rs, thetas) = splitNumeric '@' str
  -- these patterns can't fail because numericInexact always returns
  -- a LitFloating, but we have to tell GHC that they are irrefutable,
  -- or else it screams because we don't have MonadFail.
  ~(LitFloating r) <- numericInexact <$> parseReal radix rs
  ~(LitFloating theta) <- numericInexact <$> parseReal radix thetas
  let a = r * cos theta
      b = r * sin theta
  return $ LitComplex (LitFloating a) (LitFloating b)

splitNumeric :: Char -> String -> Either String (String, String)
splitNumeric on cs = case go cs of
  (_, "") -> Left $ "splitNumeric: didn't contain: #\\" ++ [on]
  other   -> Right other
  where
    go [] = ("", "")
    go (c:cs)
      | c == on = ("", cs)
      | otherwise = let (pre, suf) = go cs in (c:pre, suf)

numericInexact :: Numeric -> Numeric
numericInexact (LitInteger i)  = LitFloating $ fromIntegral i
numericInexact (LitRational r) = LitFloating $ fromRational r
numericInexact (LitFloating f) = LitFloating f

-- | This function is slightly modified from GHC's Haskell lexer.
-- We could convince Alex to do it for us with a lexer mode, but
-- then we'd be threading all the skipping through AlexActions.
-- This is a bit faster and it's basically free so might as well.
nestedComment :: AlexInput -> Int -> Alex Lexeme
nestedComment _ _ = do
    input <- alexGetInput
    go 1 input
  where 
    go 0 input = alexSetInput input >> alexMonadScan
    go n input = do
      case alexGetByte input of
        Nothing -> err input
        Just (c, input) -> do
          case chr (fromIntegral c) of
            '|' -> let temp = input
                   in case alexGetByte input of
                       Nothing -> err input
                       -- 35 is #
                       Just (35,  input) -> go (n-1) input
                       -- 124 is |
                       Just (124, input) -> go n temp
                       Just (c,   input) -> go n input
            '#' -> case alexGetByte input of
                Nothing -> err input
                Just (124, input) -> go (n+1) input
                Just (c,   input) -> go n input
            c -> go n input
    err input = alexSetInput input >> alexError' "error in nested comment"

-- | Signal a parse error at the given position.
alexErrorWithPos :: AlexPosn -> String -> Alex a
alexErrorWithPos (AlexPn _ line col) s = do
  src <- source_name <$> alexGet
  alexError $ src ++ ":" ++ show line ++ ":" ++ show col ++ ":\n" ++ s

-- | Signal a parse error at the current position of the parser.
alexError' :: String -> Alex a
alexError' s = do
  (p,_,_,_) <- alexGetInput
  alexErrorWithPos p s

}
